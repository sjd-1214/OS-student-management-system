#!/bin/bash

# Set safer bash options
set -o errexit  # Exit on error
set -o nounset  # Exit on undefined variables
set -o pipefail # Exit on pipe failures

# Constants
MAX_STUDENTS=20
MAX_NAME_LENGTH=50
MAX_PASSWORD_LENGTH=20
MIN_PASSWORD_LENGTH=4
DATA_FILE="student_data.txt"
TEACHER_ID="teacher"
TEACHER_PASSWORD="admin123"

# Grade thresholds
A_GRADE_THRESHOLD=90
A_MINUS_GRADE_THRESHOLD=85
B_PLUS_GRADE_THRESHOLD=80
B_GRADE_THRESHOLD=75
B_MINUS_GRADE_THRESHOLD=70
C_PLUS_GRADE_THRESHOLD=65
C_GRADE_THRESHOLD=60
C_MINUS_GRADE_THRESHOLD=55
D_GRADE_THRESHOLD=50
PASS_CGPA=2.0

# Global variables
declare -a students_rollNo
declare -a students_name
declare -a students_password
declare -a students_totalCourses
declare -a students_cgpa
declare -a students_isActive
declare -a courses_name
declare -a courses_marks
declare -a courses_grade
declare -a courses_gradePoints

studentCount=0
userType=0
studentIndex=-1

# Disable errexit for functions that need to return error codes
trap_on() {
    set -e
}

trap_off() {
    set +e
}

# Validation function for roll number (allow alphanumeric)
validateRollNumber() {
    local rollNo=$1
    local minLength=3
    local maxLength=10
    
    # Check length
    if [ ${#rollNo} -lt $minLength ] || [ ${#rollNo} -gt $maxLength ]; then
        echo "Roll number must be between $minLength and $maxLength characters."
        return 1
    fi
    
    # Check if contains at least one alphanumeric character and no special characters
    if ! [[ "$rollNo" =~ ^[a-zA-Z0-9]+$ ]]; then
        echo "Roll number must contain only letters and numbers."
        return 1
    fi
    
    return 0
}

# Validation function for name (only letters and spaces)
validateName() {
    local name=$1
    
    # Check if empty
    if [ -z "$name" ]; then
        echo "Name cannot be empty."
        return 1
    fi
    
    # Check length
    if [ ${#name} -gt $MAX_NAME_LENGTH ]; then
        echo "Name must be less than $MAX_NAME_LENGTH characters."
        return 1
    fi
    
    # Check if contains only letters and spaces
    if ! [[ "$name" =~ ^[a-zA-Z[:space:]]+$ ]]; then
        echo "Name must contain only letters and spaces."
        return 1
    fi
    
    return 0
}

# Validation function for password
validatePassword() {
    local password=$1
    
    # Check length
    if [ ${#password} -lt $MIN_PASSWORD_LENGTH ]; then
        echo "Password must be at least $MIN_PASSWORD_LENGTH characters."
        return 1
    fi
    
    if [ ${#password} -gt $MAX_PASSWORD_LENGTH ]; then
        echo "Password must be less than $MAX_PASSWORD_LENGTH characters."
        return 1
    fi
    
    return 0
}

# Validation function for number input
validateNumber() {
    local number=$1
    local min=$2
    local max=$3
    
    # Check if it's a number
    if ! [[ "$number" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo "Input must be a number."
        return 1
    fi
    
    # Check range
    if (( $(awk -v n="$number" -v min="$min" 'BEGIN {print (n < min)}') )) || 
       (( $(awk -v n="$number" -v max="$max" 'BEGIN {print (n > max)}') )); then
        echo "Number must be between $min and $max."
        return 1
    fi
    
    return 0
}

# Function to get valid input
getValidInput() {
    local prompt=$1
    local validationFunction=$2
    local input=""
    local isValid=false
    shift 2  # Remove first two parameters
    
    while [ "$isValid" = false ]; do
        read -p "$prompt" input
        
        if $validationFunction "$input" "$@"; then
            isValid=true
        else
            # The validation function already printed the error message
            echo "Please try again."
        fi
    done
    
    echo "$input"
}

# Function to display the main menu
displayMainMenu() {
    clear
    echo "===================================="
    echo "    STUDENT MANAGEMENT SYSTEM       "
    echo "===================================="
    echo "1. Login"
    echo "2. Load Data"
    echo "3. Exit"
    echo "===================================="
}

# Function to display the teacher menu
displayTeacherMenu() {
    clear
    echo "===================================="
    echo "         TEACHER MENU               "
    echo "===================================="
    echo "1. Add Student"
    echo "2. View Student Details"
    echo "3. Update Student Information"
    echo "4. Delete Student"
    echo "5. Assign Marks"
    echo "6. Generate Report (Ascending order by CGPA)"
    echo "7. Generate Report (Descending order by CGPA)"
    echo "8. List Passed Students"
    echo "9. List Failed Students"
    echo "10. Save Data"
    echo "11. Logout"
    echo "===================================="
}

# Function to display the student menu
displayStudentMenu() {
    clear
    echo "===================================="
    echo "         STUDENT MENU               "
    echo "===================================="
    echo "1. View Grades and CGPA"
    echo "2. Logout"
    echo "===================================="
}

# Function to authenticate user
authenticateUser() {
    trap_off  # Disable errexit for this function
    
    local userId=$1
    local password=$2
    
    # Check if teacher credentials
    if [ "$userId" == "$TEACHER_ID" ] && [ "$password" == "$TEACHER_PASSWORD" ]; then
        echo 1
        trap_on
        return 0
    fi
    
    # Check if student credentials
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$userId" ] && [ "${students_password[$i]}" == "$password" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            echo 2
            trap_on
            return 0
        fi
    done
    
    echo 0
    trap_on
    return 0
}

# Function to compare floating point numbers without using bc
# Returns 1 if condition is true, 0 otherwise
compare_floats() {
    trap_off  # Disable errexit for this function
    
    local op1=$1
    local operator=$2
    local op2=$3
    
    # Ensure inputs are numeric
    if ! [[ "$op1" =~ ^-?[0-9]+(\.[0-9]+)?$ ]] || ! [[ "$op2" =~ ^-?[0-9]+(\.[0-9]+)?$ ]]; then
        echo 0
        trap_on
        return 1
    fi
    
    # Convert to integers by multiplying by 100 to handle up to 2 decimal places
    # Use awk for more reliable float handling
    local op1_int=$(awk -v n="$op1" 'BEGIN {printf "%.0f", n*100}')
    local op2_int=$(awk -v n="$op2" 'BEGIN {printf "%.0f", n*100}')
    
    case $operator in
        ">")
            [ "$op1_int" -gt "$op2_int" ] && echo 1 || echo 0
            ;;
        ">=")
            [ "$op1_int" -ge "$op2_int" ] && echo 1 || echo 0
            ;;
        "<")
            [ "$op1_int" -lt "$op2_int" ] && echo 1 || echo 0
            ;;
        "<=")
            [ "$op1_int" -le "$op2_int" ] && echo 1 || echo 0
            ;;
        "==")
            [ "$op1_int" -eq "$op2_int" ] && echo 1 || echo 0
            ;;
        "!=")
            [ "$op1_int" -ne "$op2_int" ] && echo 1 || echo 0
            ;;
        *)
            echo 0
            ;;
    esac
    
    trap_on
    return 0
}

# Simple math function to replace basic bc operations
simple_math() {
    trap_off  # Disable errexit for this function
    
    local expr="$1"
    
    # Ensure input contains only valid characters
    if ! [[ "$expr" =~ ^[0-9\.+/-]+$ ]]; then
        echo "0.00"
        trap_on
        return 1
    fi
    
    # Handle division specifically - using awk for more reliable float handling
    if [[ "$expr" == *"/"* ]]; then
        local op1=$(echo "$expr" | cut -d'/' -f1)
        local op2=$(echo "$expr" | cut -d'/' -f2)
        
        # Check for division by zero
        if (( $(awk -v n="$op2" 'BEGIN {print (n == 0)}') )); then
            echo "0.00"
            trap_on
            return 1
        fi
        
        # Division with 2 decimal places using awk
        awk -v n1="$op1" -v n2="$op2" 'BEGIN {printf "%.2f", n1/n2}'
        trap_on
        return 0
    fi
    
    # Handle addition - using awk for more reliable float handling
    if [[ "$expr" == *"+"* ]]; then
        local op1=$(echo "$expr" | cut -d'+' -f1)
        local op2=$(echo "$expr" | cut -d'+' -f2)
        
        # Addition with 2 decimal places using awk
        awk -v n1="$op1" -v n2="$op2" 'BEGIN {printf "%.2f", n1+n2}'
        trap_on
        return 0
    fi
    
    # Just return the expression if no operations detected
    awk -v n="$expr" 'BEGIN {printf "%.2f", n}'
    trap_on
    return 0
}

# Function to calculate grade - modified to avoid name references
calculateGrade() {
    trap_off  # Disable errexit for this function
    
    local marks=$1
    
    # Convert to numeric to ensure proper comparison
    marks=$(awk -v n="$marks" 'BEGIN {printf "%.2f", n}')
    
    local grade=""
    local gradePoints=0.0
    
    if [ "$(compare_floats "$marks" ">=" "$A_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="A"
        gradePoints=4.0
    elif [ "$(compare_floats "$marks" ">=" "$A_MINUS_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="A-"
        gradePoints=3.7
    elif [ "$(compare_floats "$marks" ">=" "$B_PLUS_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="B+"
        gradePoints=3.3
    elif [ "$(compare_floats "$marks" ">=" "$B_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="B"
        gradePoints=3.0
    elif [ "$(compare_floats "$marks" ">=" "$B_MINUS_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="B-"
        gradePoints=2.7
    elif [ "$(compare_floats "$marks" ">=" "$C_PLUS_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="C+"
        gradePoints=2.3
    elif [ "$(compare_floats "$marks" ">=" "$C_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="C"
        gradePoints=2.0
    elif [ "$(compare_floats "$marks" ">=" "$C_MINUS_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="C-"
        gradePoints=1.7
    elif [ "$(compare_floats "$marks" ">=" "$D_GRADE_THRESHOLD")" -eq 1 ]; then
        grade="D"
        gradePoints=1.0
    else
        grade="F"
        gradePoints=0.0
    fi
    
    # Return both values as a colon-separated string
    echo "$grade:$gradePoints"
    trap_on
    return 0
}

# Function to calculate CGPA
calculateCGPA() {
    trap_off  # Disable errexit for this function
    
    local studentIdx=$1
    
    # Validate student index
    if [ "$studentIdx" -lt 0 ] || [ "$studentIdx" -ge "$studentCount" ]; then
        echo "0.0"
        trap_on
        return 1
    fi
    
    local totalCourses=${students_totalCourses[$studentIdx]}
    
    if [ "$totalCourses" -eq 0 ]; then
        echo "0.0"
        trap_on
        return 0
    fi
    
    local totalGradePoints=0.0
    local startIdx=$((studentIdx * 5))  # Assuming max 5 courses per student
    
    for ((i=0; i<totalCourses; i++)); do
        totalGradePoints=$(simple_math "$totalGradePoints + ${courses_gradePoints[$startIdx + $i]}")
    done
    
    echo $(simple_math "$totalGradePoints / $totalCourses")
    trap_on
    return 0
}

# Function to add a new student
addStudent() {
    if [ "$studentCount" -ge "$MAX_STUDENTS" ]; then
        read -p "Maximum student limit reached! Press Enter to continue..."
        return 1
    fi
    
    clear
    echo "===================================="
    echo "          ADD NEW STUDENT           "
    echo "===================================="
    
    # Get and validate roll number
    local rollNo=$(getValidInput "Enter Roll Number: " validateRollNumber)
    
    # Check if roll number already exists
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$rollNo" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            read -p "Student with this Roll Number already exists! Press Enter to continue..."
            return 1
        fi
    done
    
    # Get and validate name and password
    local name=$(getValidInput "Enter Name: " validateName)
    local password=$(getValidInput "Enter Password: " validatePassword)
    
    # Get number of courses (using new validateNumber function)
    local totalCourses=$(getValidInput "Enter Number of Courses (max 5): " validateNumber 1 5)
    
    # Add student to arrays
    students_rollNo[$studentCount]=$rollNo
    students_name[$studentCount]=$name
    students_password[$studentCount]=$password
    students_totalCourses[$studentCount]=$totalCourses
    students_cgpa[$studentCount]=0.0
    students_isActive[$studentCount]=1
    
    # Initialize courses
    local courseStartIdx=$((studentCount * 5))  # Assuming max 5 courses per student
    
    for ((i=0; i<totalCourses; i++)); do
        local courseName=""
        local isValidCourse=false
        
        while [ "$isValidCourse" = false ]; do
            read -p "Enter Course $((i+1)) Name: " courseName
            
            if [ -n "$courseName" ]; then
                isValidCourse=true
            else
                echo "Course name cannot be empty. Please try again."
            fi
        done
        
        courses_name[$courseStartIdx + $i]=$courseName
        courses_marks[$courseStartIdx + $i]=0.0
        courses_grade[$courseStartIdx + $i]="NA"
        courses_gradePoints[$courseStartIdx + $i]=0.0
    done
    
    ((studentCount++))
    
    read -p "Student added successfully! Press Enter to continue..."
    
    # Save data to file
    saveData
    return 0
}

# Function to view student details
viewStudentDetails() {
    clear
    echo "===================================="
    echo "        VIEW STUDENT DETAILS        "
    echo "===================================="
    
    read -p "Enter Student Roll Number: " rollNo
    
    local found=0
    
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$rollNo" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            found=1
            
            echo -e "\nRoll Number: ${students_rollNo[$i]}"
            echo "Name: ${students_name[$i]}"
            echo "CGPA: ${students_cgpa[$i]}"
            echo "Courses: ${students_totalCourses[$i]}"
            
            # Use printf for the table header
            printf "\n%-20s %-10s %-5s %-10s\n" "Course Name" "Marks" "Grade" "Grade Points"
            echo "----------------------------------------------------------"
            
            local courseStartIdx=$((i * 5))
            
            for ((j=0; j<${students_totalCourses[$i]}; j++)); do
                printf "%-20s %-10.2f %-5s %-10.2f\n" \
                    "${courses_name[$courseStartIdx + $j]}" \
                    "${courses_marks[$courseStartIdx + $j]}" \
                    "${courses_grade[$courseStartIdx + $j]}" \
                    "${courses_gradePoints[$courseStartIdx + $j]}"
            done
            
            break
        fi
    done
    
    if [ "$found" -eq 0 ]; then
        read -p "Student not found! Press Enter to continue..."
    else
        read -p $'\nPress Enter to continue...'
    fi
    
    return 0
}

# Function to update student information
updateStudentInfo() {
    clear
    echo "===================================="
    echo "    UPDATE STUDENT INFORMATION      "
    echo "===================================="
    
    read -p "Enter Student Roll Number: " rollNo
    
    local found=0
    
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$rollNo" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            found=1
            
            echo -e "\nStudent Found:"
            echo "Roll Number: ${students_rollNo[$i]}"
            echo "Name: ${students_name[$i]}"
            echo -e "\nWhat would you like to update?"
            echo "1. Name"
            echo "2. Password"
            echo "3. Course Marks"
            read -p "Enter choice: " updateChoice
            
            case $updateChoice in
                1) # Update name
                    local newName=$(getValidInput "Enter new name: " validateName)
                    students_name[$i]=$newName
                    echo "Name updated successfully!"
                    ;;
                    
                2) # Update password
                    local newPassword=$(getValidInput "Enter new password: " validatePassword)
                    students_password[$i]=$newPassword
                    echo "Password updated successfully!"
                    ;;
                    
                3) # Update course marks
                    if [ "${students_totalCourses[$i]}" -gt 0 ]; then
                        echo -e "\nSelect course to update marks:"
                        
                        local courseStartIdx=$((i * 5))
                        
                        for ((j=0; j<${students_totalCourses[$i]}; j++)); do
                            echo "$((j+1)). ${courses_name[$courseStartIdx + $j]}"
                        done
                        
                        read -p "Enter choice: " courseChoice
                        
                        if [ "$courseChoice" -ge 1 ] && [ "$courseChoice" -le "${students_totalCourses[$i]}" ]; then
                            # Get and validate marks (using new validateNumber function)
                            local newMarks=$(getValidInput "Enter new marks for ${courses_name[$courseStartIdx + $((courseChoice-1))]}: " validateNumber 0 100)
                            
                            courses_marks[$courseStartIdx + $((courseChoice-1))]=$newMarks
                            
                            # Calculate grade and grade points with new function approach
                            local grade_result=$(calculateGrade "$newMarks")
                            local grade=$(echo "$grade_result" | cut -d':' -f1)
                            local gradePoints=$(echo "$grade_result" | cut -d':' -f2)
                            
                            # Update the arrays
                            courses_grade[$courseStartIdx + $((courseChoice-1))]="$grade"
                            courses_gradePoints[$courseStartIdx + $((courseChoice-1))]="$gradePoints"
                            
                            # Recalculate CGPA
                            students_cgpa[$i]=$(calculateCGPA $i)
                            
                            echo "Marks updated successfully!"
                        else
                            echo "Invalid course selection!"
                        fi
                    else
                        echo "No courses available to update!"
                    fi
                    ;;
                    
                *)
                    echo "Invalid choice!"
            esac
            
            break
        fi
    done
    
    if [ "$found" -eq 0 ]; then
        read -p "Student not found! Press Enter to continue..."
    else
        read -p $'\nPress Enter to continue...'
        
        # Save data to file
        saveData
    fi
    
    return 0
}

# Function to delete a student
deleteStudent() {
    clear
    echo "===================================="
    echo "          DELETE STUDENT            "
    echo "===================================="
    
    read -p "Enter Student Roll Number to delete: " rollNo
    
    local found=0
    
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$rollNo" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            found=1
            
            echo -e "\nStudent Found:"
            echo "Roll Number: ${students_rollNo[$i]}"
            echo "Name: ${students_name[$i]}"
            read -p $'\nAre you sure you want to delete this student? (Y/N): ' confirmation
            
            if [[ "${confirmation^^}" == "Y" ]]; then
                students_isActive[$i]=0
                echo "Student deleted successfully!"
                
                # Save data to file
                saveData
            else
                echo "Deletion cancelled."
            fi
            
            break
        fi
    done
    
    if [ "$found" -eq 0 ]; then
        read -p "Student not found! Press Enter to continue..."
    else
        read -p $'\nPress Enter to continue...'
    fi
    
    return 0
}

# Function to assign marks to students
assignMarks() {
    clear
    echo "===================================="
    echo "            ASSIGN MARKS            "
    echo "===================================="
    
    read -p "Enter Student Roll Number: " rollNo
    
    local found=0
    
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_rollNo[$i]}" == "$rollNo" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
            found=1
            
            echo -e "\nAssigning marks for ${students_name[$i]} (Roll No: ${students_rollNo[$i]})"
            
            local courseStartIdx=$((i * 5))
            
            for ((j=0; j<${students_totalCourses[$i]}; j++)); do
                # Get and validate marks (using new validateNumber function)
                local marks=$(getValidInput "Enter marks for ${courses_name[$courseStartIdx + $j]} (0-100): " validateNumber 0 100)
                
                courses_marks[$courseStartIdx + $j]=$marks
                
                # Calculate grade and grade points with new function approach
                local grade_result=$(calculateGrade "$marks")
                local grade=$(echo "$grade_result" | cut -d':' -f1)
                local gradePoints=$(echo "$grade_result" | cut -d':' -f2)
                
                # Update the arrays
                courses_grade[$courseStartIdx + $j]="$grade"
                courses_gradePoints[$courseStartIdx + $j]="$gradePoints"
            done
            
            # Calculate CGPA
            students_cgpa[$i]=$(calculateCGPA $i)
            
            echo -e "\nMarks assigned successfully! CGPA: ${students_cgpa[$i]}"
            
            # Save data to file
            saveData
            
            break
        fi
    done
    
    if [ "$found" -eq 0 ]; then
        read -p "Student not found! Press Enter to continue..."
    else
        read -p $'\nPress Enter to continue...'
    fi
    
    return 0
}

# Function to generate report
generateReport() {
    clear
    echo "===================================="
    echo "          STUDENT REPORT            "
    echo "===================================="
    
    local sortOrder=$1
    
    # Count active students
    local activeCount=0
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ]; then
            ((activeCount++))
        fi
    done
    
    if [ "$activeCount" -eq 0 ]; then
        read -p "No students found! Press Enter to continue..."
        return 1
    fi
    
    # Create temporary arrays for sorting
    local -a tempIndices
    local index=0
    
    # Get indices of active students
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ]; then
            tempIndices[$index]=$i
            ((index++))
        fi
    done
    
    # Sort by CGPA
    for ((i=0; i<activeCount-1; i++)); do
        for ((j=0; j<activeCount-i-1; j++)); do
            local cgpa1=${students_cgpa[${tempIndices[$j]}]}
            local cgpa2=${students_cgpa[${tempIndices[$j+1]}]}
            
            if { [ "$sortOrder" -eq 1 ] && [ "$(compare_floats "$cgpa1" ">" "$cgpa2")" -eq 1 ]; } || \
               { [ "$sortOrder" -eq 2 ] && [ "$(compare_floats "$cgpa1" "<" "$cgpa2")" -eq 1 ]; }; then
                # Swap indices
                local temp=${tempIndices[$j]}
                tempIndices[$j]=${tempIndices[$j+1]}
                tempIndices[$j+1]=$temp
            fi
        done
    done
    
    # Print report header
    printf "%-10s %-20s %-10s %-15s\n" "Roll No" "Name" "CGPA" "Status"
    echo "----------------------------------------------------"
    
    # Print sorted student data
    for ((i=0; i<activeCount; i++)); do
        local idx=${tempIndices[$i]}
        local status="PASS"
        
        if [ "$(compare_floats "${students_cgpa[$idx]}" "<" "$PASS_CGPA")" -eq 1 ]; then
            status="FAIL"
        fi
        
        printf "%-10s %-20s %-10.2f %-15s\n" \
            "${students_rollNo[$idx]}" \
            "${students_name[$idx]}" \
            "${students_cgpa[$idx]}" \
            "$status"
    done
    
    read -p $'\nPress Enter to continue...'
    return 0
}

# Function to list passed students
listPassedStudents() {
    clear
    echo "===================================="
    echo "         PASSED STUDENTS            "
    echo "===================================="
    
    # Count passed students
    local passedCount=0
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ] && [ "$(compare_floats "${students_cgpa[$i]}" ">=" "$PASS_CGPA")" -eq 1 ]; then
            ((passedCount++))
        fi
    done
    
    if [ "$passedCount" -eq 0 ]; then
        read -p "No passed students found! Press Enter to continue..."
        return 1
    fi
    
    # Print report header
    printf "%-10s %-20s %-10s\n" "Roll No" "Name" "CGPA"
    echo "----------------------------------------"
    
    # Print passed student data
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ] && [ "$(compare_floats "${students_cgpa[$i]}" ">=" "$PASS_CGPA")" -eq 1 ]; then
            printf "%-10s %-20s %-10.2f\n" \
                "${students_rollNo[$i]}" \
                "${students_name[$i]}" \
                "${students_cgpa[$i]}"
        fi
    done
    
    read -p $'\nPress Enter to continue...'
    return 0
}

# Function to list failed students
listFailedStudents() {
    clear
    echo "===================================="
    echo "         FAILED STUDENTS            "
    echo "===================================="
    
    # Count failed students
    local failedCount=0
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ] && [ "$(compare_floats "${students_cgpa[$i]}" "<" "$PASS_CGPA")" -eq 1 ]; then
            ((failedCount++))
        fi
    done
    
    if [ "$failedCount" -eq 0 ]; then
        read -p "No failed students found! Press Enter to continue..."
        return 1
    fi
    
    # Print report header
    printf "%-10s %-20s %-10s\n" "Roll No" "Name" "CGPA"
    echo "----------------------------------------"
    
    # Print failed student data
    for ((i=0; i<studentCount; i++)); do
        if [ "${students_isActive[$i]}" -eq 1 ] && [ "$(compare_floats "${students_cgpa[$i]}" "<" "$PASS_CGPA")" -eq 1 ]; then
            printf "%-10s %-20s %-10.2f\n" \
                "${students_rollNo[$i]}" \
                "${students_name[$i]}" \
                "${students_cgpa[$i]}"
        fi
    done
    
    read -p $'\nPress Enter to continue...'
    return 0
}

# Function to save data to file
saveData() {
    # Ensure we have write permissions before attempting to write
    if [ ! -f "$DATA_FILE" ] || [ -w "$DATA_FILE" ]; then
        # Create backup of existing file
        if [ -f "$DATA_FILE" ]; then
            cp "$DATA_FILE" "${DATA_FILE}.bak"
        fi
        
        > "$DATA_FILE"  # Clear the file
        
        # Write header row
        echo "# Student Management System Data File" >> "$DATA_FILE"
        echo "# Format: studentCount=$studentCount" >> "$DATA_FILE"
        echo "# STUDENT_DATA: rollNo|name|password|totalCourses|cgpa|isActive" >> "$DATA_FILE"
        echo "# COURSE_DATA: courseName|marks|grade|gradePoints" >> "$DATA_FILE"
        echo "#------------------------------------------------------------" >> "$DATA_FILE"
        
        # Write each student's data in tabular format
        for ((i=0; i<studentCount; i++)); do
            # Write student info with pipe delimiter
            echo "STUDENT|${students_rollNo[$i]}|${students_name[$i]}|${students_password[$i]}|${students_totalCourses[$i]}|${students_cgpa[$i]}|${students_isActive[$i]}" >> "$DATA_FILE"
            
            # Write course data
            local courseStartIdx=$((i * 5))
            
            for ((j=0; j<${students_totalCourses[$i]}; j++)); do
                echo "COURSE|${courses_name[$courseStartIdx + $j]}|${courses_marks[$courseStartIdx + $j]}|${courses_grade[$courseStartIdx + $j]}|${courses_gradePoints[$courseStartIdx + $j]}" >> "$DATA_FILE"
            done
            
            # Add a separator between students
            echo "#------------------------------------------------------------" >> "$DATA_FILE"
        done
        
        # Ensure data is written to disk
        sync
        
        return 0
    else
        echo "Error: Cannot write to data file. Permission denied."
        read -p "Press Enter to continue..."
        return 1
    fi
}

# Function to load data from file
loadData() {
    trap_off  # Disable errexit for this function
    
    if [ ! -f "$DATA_FILE" ]; then
        trap_on
        return 1
    fi
    
    if [ ! -r "$DATA_FILE" ]; then
        echo "Error: Cannot read data file. Permission denied."
        read -p "Press Enter to continue..."
        trap_on
        return 1
    fi
    
    # Initialize variables
    studentCount=0
    
    # Reset arrays
    students_rollNo=()
    students_name=()
    students_password=()
    students_totalCourses=()
    students_cgpa=()
    students_isActive=()
    courses_name=()
    courses_marks=()
    courses_grade=()
    courses_gradePoints=()
    
    # Legacy format detection flag
    local legacyFormat=false
    
    # Read first line to check format
    local firstLine
    read -r firstLine < "$DATA_FILE"
    
    # Check if it's the legacy format (just a number for studentCount)
    if [[ "$firstLine" =~ ^[0-9]+$ ]]; then
        legacyFormat=true
        studentCount=$firstLine
    fi
    
    if [ "$legacyFormat" = true ]; then
        # Handle legacy format
        # Read each student's data
        for ((i=0; i<studentCount; i++)); do
            read -r students_rollNo[$i]
            read -r students_name[$i]
            read -r students_password[$i]
            read -r students_totalCourses[$i]
            read -r students_cgpa[$i]
            read -r students_isActive[$i]
            
            # Read course data
            local courseStartIdx=$((i * 5))
            
            for ((j=0; j<${students_totalCourses[$i]}; j++)); do
                read -r courses_name[$courseStartIdx + $j]
                read -r courses_marks[$courseStartIdx + $j]
                read -r courses_grade[$courseStartIdx + $j]
                read -r courses_gradePoints[$courseStartIdx + $j]
            done
        done < <(tail -n +2 "$DATA_FILE")  # Skip the first line (studentCount)
    else
        # Handle new tabular format
        local currentStudent=-1
        local courseCount=0
        
        # Read file line by line
        while IFS= read -r line || [ -n "$line" ]; do
            # Skip comments and separators
            [[ "$line" =~ ^#.*$ ]] && continue
            
            # Split the line by pipe delimiter
            IFS='|' read -r recordType data1 data2 data3 data4 data5 data6 <<< "$line"
            
            if [ "$recordType" = "STUDENT" ]; then
                # New student record
                ((currentStudent++))
                students_rollNo[$currentStudent]=$data1
                students_name[$currentStudent]=$data2
                students_password[$currentStudent]=$data3
                students_totalCourses[$currentStudent]=$data4
                students_cgpa[$currentStudent]=$data5
                students_isActive[$currentStudent]=$data6
                
                # Reset course count for new student
                courseCount=0
            elif [ "$recordType" = "COURSE" ] && [ $currentStudent -ge 0 ]; then
                # Course record for current student
                local courseIdx=$((currentStudent * 5 + courseCount))
                
                courses_name[$courseIdx]=$data1
                courses_marks[$courseIdx]=$data2
                courses_grade[$courseIdx]=$data3
                courses_gradePoints[$courseIdx]=$data4
                
                # Increment the course count
                ((courseCount++))
            fi
        done < "$DATA_FILE"
        
        # Update student count
        studentCount=$((currentStudent + 1))
    fi
    
    trap_on
    return 0
}

# Function for student to view their grades
viewStudentGrades() {
    local studentIdx=$1
    
    # Validate student index
    if [ "$studentIdx" -lt 0 ] || [ "$studentIdx" -ge "$studentCount" ]; then
        echo "Error: Invalid student index."
        read -p "Press Enter to continue..."
        return 1
    fi
    
    clear
    echo "===================================="
    echo "        YOUR GRADES AND CGPA        "
    echo "===================================="
    
    echo "Name: ${students_name[$studentIdx]}"
    echo "Roll Number: ${students_rollNo[$studentIdx]}"
    echo "CGPA: ${students_cgpa[$studentIdx]}"
    
    # Fix: Use printf instead of echo for the table header
    printf "\n%-20s %-10s %-5s\n" "Course Name" "Marks" "Grade"
    echo "---------------------------------------"
    
    local courseStartIdx=$((studentIdx * 5))
    
    for ((i=0; i<${students_totalCourses[$studentIdx]}; i++)); do
        printf "%-20s %-10.2f %-5s\n" \
            "${courses_name[$courseStartIdx + $i]}" \
            "${courses_marks[$courseStartIdx + $i]}" \
            "${courses_grade[$courseStartIdx + $i]}"
    done
    
    read -p $'\nPress Enter to continue...'
    return 0
}

# Main program loop
# Initialize - trap on by default
trap_on

# Call loadData() to load existing data when the program starts
loadData

while true; do
    if [ "$userType" -eq 0 ]; then
        displayMainMenu
        read -p "Enter your choice: " choice
        
        case $choice in
            1) # Login
                clear
                echo "===== LOGIN ====="
                read -p "Enter User ID: " userId
                read -p "Enter Password: "  password
                echo
                
                userType=$(authenticateUser "$userId" "$password")
                
                if [ "$userType" -eq 0 ]; then
                    read -p "Invalid credentials! Press Enter to continue..."
                elif [ "$userType" -eq 2 ]; then
                    # Find student index
                    for ((i=0; i<studentCount; i++)); do
                        if [ "${students_rollNo[$i]}" == "$userId" ] && [ "${students_isActive[$i]}" -eq 1 ]; then
                            studentIndex=$i
                            break
                        fi
                    done
                fi
                ;;
            
            2) # Load Data
                loadData
                read -p "Data loaded successfully! Press Enter to continue..."
                ;;
                
            3) # Exit
                echo "Thank you for using Student Management System!"
                exit 0
                ;;
                
            *)
                read -p "Invalid choice! Press Enter to continue..."
        esac
    elif [ "$userType" -eq 1 ]; then # Teacher menu
        displayTeacherMenu
        read -p "Enter your choice: " choice
        
        case $choice in
            1) addStudent ;;
            2) viewStudentDetails ;;
            3) updateStudentInfo ;;
            4) deleteStudent ;;
            5) assignMarks ;;
            6) generateReport 1 ;;  # Ascending
            7) generateReport 2 ;;  # Descending
            8) listPassedStudents ;;
            9) listFailedStudents ;;
            10) 
                saveData
                read -p "Data saved successfully! Press Enter to continue..."
                ;;
            11) 
                userType=0
                read -p "Logged out successfully! Press Enter to continue..."
                ;;
            *)
                read -p "Invalid choice! Press Enter to continue..."
        esac
    elif [ "$userType" -eq 2 ] && [ "$studentIndex" -ne -1 ]; then # Student menu
        displayStudentMenu
        read -p "Enter your choice: " choice
        
        case $choice in
            1) viewStudentGrades "$studentIndex" ;;
            2) 
                userType=0
                studentIndex=-1
                read -p "Logged out successfully! Press Enter to continue..."
                ;;
            *)
                read -p "Invalid choice! Press Enter to continue..."
        esac
    fi
done